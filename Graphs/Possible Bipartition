class Solution {
public:
    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {
        //build adjanceny list
        vector<vector<int>> graph(n+1);
        for(const auto& dislike: dislikes){
            int a = dislike[0];
            int b = dislike[1];
            graph[a].push_back(b);
            graph[b].push_back(a);
        }
        vector<int> color(n+1, 0); // 0 - uncolured, 1 = red, 2 = blue
        for(int i =1; i<=n; i++){
            if(color[i] == 0){
                if(!dfs(i, 1, graph, color)){
                    return false;
                }
            }  
            
        }
        return true;
    }
    private:
        bool dfs(int node, int currentColor, vector<vector<int>>& graph, vector<int>& color){
            color[node] = currentColor;
            for(int neighbor : graph[node]){
                if(color[neighbor] == 0){
                    //recursively color neighbor with opposite color
                    if(!dfs(neighbor, 3- currentColor, graph, color)){
                        return false;
                    }
                   
                }
                 else if(color[neighbor] == currentColor){
                        //conflict : neighbor has same color
                        return false;
                }

            }
        return true;
    }

    

};
