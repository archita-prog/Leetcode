class Solution {
public:
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();

        //build adjacnecy list for the graph (poorer->richer)

        vector<vector<int>> graph(n);
        for(const auto& edge: richer){
            int rich = edge[0];
            int poor = edge[1];

            graph[poor].push_back(rich); // poor person points to richer people

        }
        vector<int> answer(n,-1);

        //dfs function with memorization
        function<int(int)> dfs = [&](int person)->int{
            //if already computed, return the result
            if(answer[person] !=-1){
                return answer[person];
            }
            //start with the person themselves
            int quietestPerson = person;

            //check all richer people
            for(int richerPerson : graph[person]){
                int candidate = dfs(richerPerson);
                if(quiet[candidate] < quiet[quietestPerson]){
                    quietestPerson = candidate;
                }
            }
            //memorize the result
            answer[person] = quietestPerson;
            return quietestPerson;
        };
        for(int i =0; i<n; i++){
            if(answer[i] == -1){
                dfs(i);
            }
        }
        return answer;
        
    }
};
