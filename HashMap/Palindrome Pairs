class Solution {
public:
    bool isPalindrome(const string &s, int l, int r) {
        while (l < r) {
            if (s[l++] != s[r--]) return false;
        }
        return true;
    }

    vector<vector<int>> palindromePairs(vector<string>& words) {
        unordered_map<string, int> mp;
        vector<vector<int>> res;

        // Store reversed words
        for (int i = 0; i < words.size(); i++) {
            string rev = words[i];
            reverse(rev.begin(), rev.end());
            mp[rev] = i;
        }

        for (int i = 0; i < words.size(); i++) {
            string &w = words[i];
            int n = w.size();

            for (int k = 0; k <= n; k++) {
                // Split into prefix and suffix
                // prefix: [0..k-1], suffix: [k..n-1]

                // Case 1: prefix palindrome
                if (isPalindrome(w, 0, k - 1)) {
                    string suffix = w.substr(k);
                    if (mp.count(suffix) && mp[suffix] != i) {
                        res.push_back({mp[suffix], i});
                    }
                }

                // Case 2: suffix palindrome (avoid duplicate at k=0)
                if (k != n && isPalindrome(w, k, n - 1)) {
                    string prefix = w.substr(0, k);
                    if (mp.count(prefix) && mp[prefix] != i) {
                        res.push_back({i, mp[prefix]});
                    }
                }
            }
        }
        return res;
    }
};
